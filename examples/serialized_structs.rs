extern crate serde_json;
extern crate rwinstructs;
extern crate rustymft;
use rwinstructs::serialize;
use rustymft::entry;
use rustymft::attribute;
use std::io::Cursor;

fn print_entry_header(){
    let header_buffer: &[u8] = &[
        0x46,0x49,0x4C,0x45,0x30,0x00,0x03,0x00,0xCC,0xB3,0x7D,0x84,0x0C,0x00,0x00,0x00,
        0x05,0x00,0x01,0x00,0x38,0x00,0x05,0x00,0x48,0x03,0x00,0x00,0x00,0x04,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xD5,0x95,0x00,0x00,
        0x53,0x57,0x81,0x37,0x00,0x00,0x00,0x00
    ];

    let entry_header = match entry::EntryHeader::new(header_buffer,None) {
        Ok(entry_header) => entry_header,
        Err(error) => panic!(error)
    };

    println!("{}",serde_json::to_string_pretty(&entry_header).unwrap());
}
fn print_attribute_header_01(){
    let raw: &[u8] = &[
        0x10,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x48,0x00,0x00,0x00,0x18,0x00,0x00,0x00
    ];

    let attribute_buffer = Cursor::new(raw);

    let attribute_header = match attribute::AttributeHeader::new(attribute_buffer) {
        Ok(attribute_header) => attribute_header,
        Err(error) => panic!(error)
    };

    println!("{}",serde_json::to_string_pretty(&attribute_header).unwrap());
}
fn print_attribute_header_02() {
    let raw: &[u8] = &[
        0x80,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x01,0x00,0x40,0x00,0x00,0x00,0x06,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBF,0x1E,0x01,0x00,0x00,0x00,0x00,0x00,
        0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xEC,0x11,0x00,0x00,0x00,0x00,
        0x00,0x00,0xEC,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0xEC,0x11,0x00,0x00,0x00,0x00,
        0x33,0x20,0xC8,0x00,0x00,0x00,0x0C,0x32,0xA0,0x56,0xE3,0xE6,0x24,0x00,0xFF,0xFF
    ];

    let attribute_buffer = Cursor::new(raw);

    let attribute_header = match attribute::AttributeHeader::new(attribute_buffer) {
        Ok(attribute_header) => attribute_header,
        Err(error) => panic!(error)
    };

    println!("{}",serde_json::to_string_pretty(&attribute_header).unwrap());
}
fn print_attribute_header_03() {
    let raw: &[u8] = &[
        0x80,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x01,0x04,0x40,0x00,0x00,0x00,0x01,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x11,0xD1,0x00,0x00,0x00,0x00,0x00,
        0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x1F,0x11,0x0D,0x00,0x00,0x00,
        0x00,0xF0,0x1F,0x11,0x0D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x24,0x00,0x42,0x00,0x61,0x00,0x64,0x00,0x04,0xFF,0x11,0xD1,0x00,0x00,0x00,0x00
    ];

    let attribute_buffer = Cursor::new(raw);

    let attribute_header = match attribute::AttributeHeader::new(attribute_buffer) {
        Ok(attribute_header) => attribute_header,
        Err(error) => panic!(error)
    };

    println!("{}",serde_json::to_string_pretty(&attribute_header).unwrap());
}

fn main(){
    unsafe {
        serialize::U64_SERIALIZATION = serialize::U64Serialization::AsString
    }
    print_entry_header();
    print_attribute_header_01();
    print_attribute_header_02();
    print_attribute_header_03();
}
